#clearsnippets

snippet f "func"
func ${1:FuncName}($2)${3: }{
	${4:// @TODO}
}
endsnippet

snippet tf "func (type)"
func (${1/^\*?(.).*/\l$1/} ${1:Type}) ${2:FuncName}($3)${4: }{
	${5:// @TODO}
}
endsnippet

snippet s "type struct"
type ${1:TypeName} struct {
	${2:// @TODO}
}
endsnippet

snippet t "type"
type ${1:TypeName} ${2:description}
endsnippet

snippet p "package"
package ${1:`!v expand('%:p:h:t')`}
endsnippet

snippet te "func Test"
func Test${1:FuncName}(t *testing.T) {
	${2:// @TODO}
}
endsnippet

snippet ti "interface"
type ${1:SmthDoer} interface {
	${2:// @TODO}
}
endsnippet

snippet todo "@TODO"
// @TODO $0
endsnippet

snippet i "if "
if $1 {
	${VISUAL}$2
} $3
endsnippet

snippet ifer "if err != nil"
if err != nil {
	return ${2:$1err}
}
endsnippet

snippet ifok "if !ok"
if !ok {
	${2:return $1}
}
endsnippet

snippet ifok= "if !ok"
if ok := $1; !ok {
	${3:return $2}
}
endsnippet

snippet ifer= "if err := *; err != nil"
if err := $1; err != nil {
	return ${3:$2err}
}
endsnippet

snippet iferp "if err != nil panic"
if err != nil {
	panic(err)
}
endsnippet

snippet iferf "if err != nil fatal"
if err != nil {
	log.Fatal(${2:$1err})
}
endsnippet

snippet iferl "if err != nil fatal"
if err != nil {
	log.Println(${4:"$1", $2err$3})
}
endsnippet

snippet ifert "if err != nil testing"
if err != nil {
	t.${1:Error$2}(${4:$3err})
}
endsnippet

snippet fora "for range" 
for ${1:_}, ${2:val} := range ${3:by} {
	$4	
}
endsnippet

snippet r "return"
return $0
endsnippet

snippet fs "... string"
${1:Name} string$0
endsnippet

snippet exp "test expected"
actual := ${1:"Something"}
if actual != ${2:"Actual"} {
	t.Fatal("unexpected", actual)
}
endsnippet

snippet ne "errors.New" w
errors.New($1)$2
endsnippet

global !p
def to_undercase(name):
	s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
	return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()
endglobal

snippet "((\w+)\s*((map\[\w+\])*(\[\])?[\w.]+({})?)) js$" "json annotation" br
`!p snip.rv=match.group(1)` \`json:"`!p snip.rv=to_undercase(match.group(2))`"\`
endsnippet



snippet lgi "log.Info(...)"
log.Info("$1"$2)
endsnippet

snippet lge "log.Error(...)"
log.Error("$1"$2)
endsnippet

snippet lgc "log.Critical(...)"
log.Critical("$1"$2)
endsnippet

snippet lgd "log.Debug(...)"
log.Debug("$1"$2)
endsnippet

snippet lgw "log.Warning(...)"
log.Warning("$1"$2)
endsnippet

snippet lgn "log.Notice(...)"
log.Notice("$1"$2)
endsnippet

snippet lgf "log.Fatal(...)"
log.Fatal$1("$2"$3)
endsnippet



snippet lg "log.Print(...)"
log.Print($0)
endsnippet

snippet lgpf "log.Printf(...)"
log.Printf("$1", $2)
endsnippet

snippet lgv "log.Printf(var = %v)"
log.Printf("$1=%${2:#v}", $1$3)
endsnippet

snippet lgl "log.Println(...)"
log.Println(${3:"$1"$2})
endsnippet

snippet lf "log.Fatal(...)"
log.Fatal($0)
endsnippet

snippet lff "log.Fatalf(...)"
log.Fatalf("$1", $2)
endsnippet

snippet lfl "log.Fatalln(...)"
log.Fatalln(${3:"$1"$2})
endsnippet

snippet sf "fmt.Sprintf(...)" w
fmt.Sprintf("$1", $2)
endsnippet

snippet ef "fmt.Sprintf(...)" w
fmt.Errorf("$1", $2)
endsnippet

snippet egc "error getting map" w
errors.New(fmt.Sprintf("Cannot get $1 from config: %s", ${3:$2, err.Error()})
endsnippet

snippet =err "..., err := ..."
$1, err ${5::}= $2
if err != nil {
	return $3, ${4:err}
}
endsnippet

snippet sorterBy "sorter"
type ${1:sortBy} []${2:type}

func (${3:v} $1) Len() int      { return len($3) }
func ($3 $1) Swap(i, j int) { $3[i], $3[j] = $3[j], $3[i] }
func ($3 $1) Less(i, j int) bool {
	return ${4:$3[i] < $3[j]}
}
endsnippet
